from __future__ import annotations

import random
from dataclasses import dataclass
from typing import Sequence


@dataclass
class SpinResult:
    symbols: tuple[str, str, str]
    winnings: int
    message: str
    jackpot_win: int = 0
    free_spins: int = 0


class SlotMachine:
    key: str
    title: str
    description: str

    def __init__(self, reel: Sequence[str]) -> None:
        self._reel: tuple[str, ...] = tuple(reel)
        if len(self._reel) == 0:
            raise ValueError("Reel must contain at least one symbol")

    @property
    def reel(self) -> Sequence[str]:
        return self._reel

    def spin(
        self,
        bet: int,
        rng: random.Random | None = None,
        *,
        jackpot_balance: int = 0,
    ) -> SpinResult:
        if rng is None:
            rng = random
        symbols = tuple(rng.choice(self._reel) for _ in range(3))  # type: ignore[arg-type]
        winnings, body, jackpot_win, extras = self.evaluate(symbols, bet, jackpot_balance)
        header = f"[ {' | '.join(symbols)} ]"
        message = f"{header}\n{body}"
        free_spins = extras.get("free_spins", 0)
        return SpinResult(
            symbols=symbols,
            winnings=winnings,
            message=message,
            jackpot_win=jackpot_win,
            free_spins=free_spins,
        )

    def evaluate(
        self, symbols: tuple[str, str, str], bet: int, jackpot_balance: int
    ) -> tuple[int, str, int, dict[str, int]]:
        raise NotImplementedError

    def supports_jackpot(self) -> bool:
        return False

    def jackpot_contribution(self, bet: int) -> int:
        return 0


class FruitMachine(SlotMachine):
    key = "fruit"
    title = "–§—Ä—É–∫—Ç–æ–≤—ã–π –ö–æ–∫—Ç–µ–π–ª—å"
    description = "–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –∞–≤—Ç–æ–º–∞—Ç —Å –ø—Ä–æ—Å—Ç—ã–º–∏ –ø—Ä–∞–≤–∏–ª–∞–º–∏ –∏ –±—ã—Å—Ç—Ä—ã–º–∏ –≤—ã–∏–≥—Ä—ã—à–∞–º–∏."

    def __init__(
        self,
        reel: Sequence[str],
        special_payouts: dict[tuple[str, str, str], int],
        *,
        title: str | None = None,
        description: str | None = None,
    ) -> None:
        super().__init__(reel)
        self._special_payouts = special_payouts
        if title:
            self.title = title
        if description:
            self.description = description

    def evaluate(
        self, symbols: tuple[str, str, str], bet: int, jackpot_balance: int
    ) -> tuple[int, str, int, dict[str, int]]:
        payout = self._special_payouts.get(symbols)
        if payout:
            winnings = bet * payout
            if symbols == ("üíé", "üíé", "üíé"):
                return winnings, "üí• –î–ñ–ï–ö–ü–û–¢! üí• –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ {0} —Ñ–∏—à–µ–∫!".format(winnings), 0, {}
            if symbols == ("üçÄ", "üçÄ", "üçÄ"):
                return winnings, "–£–¥–∞—á–∞ –Ω–∞ –≤–∞—à–µ–π —Å—Ç–æ—Ä–æ–Ω–µ! –¢—Ä–∏ –∫–ª–µ–≤–µ—Ä–∞ –ø—Ä–∏–Ω–æ—Å—è—Ç {0} —Ñ–∏—à–µ–∫.".format(winnings), 0, {}
            if symbols == ("üîî", "üîî", "üîî"):
                return winnings, "üîî –ó–≤–æ–Ω –º–æ–Ω–µ—Ç! üîî –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ {0} —Ñ–∏—à–µ–∫.".format(winnings), 0, {}
            return winnings, "–í—ã —Å–æ—Ä–≤–∞–ª–∏ –∫—Ä—É–ø–Ω—ã–π –≤—ã–∏–≥—Ä—ã—à: {0} —Ñ–∏—à–µ–∫!".format(winnings), 0, {}

        if symbols[0] == symbols[1] == symbols[2]:
            winnings = bet * 5
            return winnings, "–¢—Ä–∏ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ {0} —Ñ–∏—à–µ–∫.".format(winnings), 0, {}

        if len({symbols[0], symbols[1], symbols[2]}) == 2:
            winnings = bet * 2
            return winnings, "–î–≤–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ {0} —Ñ–∏—à–µ–∫.".format(winnings), 0, {}

        return 0, "–£–≤—ã, –≤ —ç—Ç–æ—Ç —Ä–∞–∑ –Ω–µ –ø–æ–≤–µ–∑–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑!", 0, {}


class WildJackpotMachine(SlotMachine):
    key = "jackpot"
    title = "–î–∏–∫–∏–π –î–∂–µ–∫–ø–æ—Ç"
    description = "Wild-—Å–∏–º–≤–æ–ª –∑–∞–º–µ–Ω—è–µ—Ç –æ—Å—Ç–∞–ª—å–Ω—ã–µ, —É–º–Ω–æ–∂–∞—è –≤—ã–∏–≥—Ä—ã—à –∏ –ø–æ–ø–æ–ª–Ω—è—è –¥–∂–µ–∫–ø–æ—Ç."

    def __init__(
        self,
        reel: Sequence[str] | None = None,
        *,
        wild_symbol: str = "üóø",
        jackpot_percent: float = 0.01,
        triple_payouts: dict[str, int] | None = None,
        double_payouts: dict[str, int] | None = None,
        jackpot_multiplier: int = 60,
        jackpot_message: str | None = None,
        title: str | None = None,
        description: str | None = None,
        jackpot_seed: int = 0,
    ) -> None:
        reel = tuple(reel or ("üêç", "üêû", "üëÅÔ∏è", "üè∫", wild_symbol))
        super().__init__(reel)
        self._wild = wild_symbol
        self._jackpot_percent = max(0.0, jackpot_percent)
        self._triple_payouts = triple_payouts or {
            "üêç": 20,
            "üêû": 16,
            "üëÅÔ∏è": 12,
            "üè∫": 10,
        }
        self._double_payouts = double_payouts or {
            "üêç": 5,
            "üêû": 4,
            "üëÅÔ∏è": 3,
            "üè∫": 2,
        }
        self._jackpot_multiplier = jackpot_multiplier
        self._jackpot_message = (
            jackpot_message
            or "üëë –ì–ª–∞–≤–Ω—ã–π –ø—Ä–∏–∑! –í—ã –∑–∞–±–∏—Ä–∞–µ—Ç–µ –¥–∂–µ–∫–ø–æ—Ç –≤ {jackpot} —Ñ–∏—à–µ–∫ + –±–∞–∑–æ–≤—ã–π –≤—ã–∏–≥—Ä—ã—à {base} (–∏—Ç–æ–≥–æ {total})."
        )
        self.jackpot_seed = max(0, jackpot_seed)
        if title:
            self.title = title
        if description:
            self.description = description

    def evaluate(
        self, symbols: tuple[str, str, str], bet: int, jackpot_balance: int
    ) -> tuple[int, str, int, dict[str, int]]:
        wild_count = symbols.count(self._wild)
        if wild_count == 3:
            base = bet * self._jackpot_multiplier
            total = base + jackpot_balance
            return (
                total,
                self._jackpot_message.format(jackpot=jackpot_balance, base=base, total=total),
                jackpot_balance,
                {},
            )

        non_wild = [s for s in symbols if s != self._wild]
        if wild_count:
            if not non_wild:
                base = bet * self._jackpot_multiplier
                total = base + jackpot_balance
                return (
                    total,
                    self._jackpot_message.format(jackpot=jackpot_balance, base=base, total=total),
                    jackpot_balance,
                    {},
                )

            best_symbol = self._choose_best_symbol(non_wild)
            matches = non_wild.count(best_symbol) + wild_count
            multiplier = 0
            if matches >= 3:
                multiplier = self._triple_payouts.get(best_symbol, 0)
            elif matches == 2:
                multiplier = self._double_payouts.get(best_symbol, 0)

            if multiplier:
                winnings = bet * multiplier
                if matches >= 3:
                    return winnings, (
                        f"{self._wild} –ø–æ–¥–¥–µ—Ä–∂–∞–ª –∫–æ–º–±–∏–Ω–∞—Ü–∏—é! –¢—Ä–∏ {best_symbol} –ø—Ä–∏–Ω–æ—Å—è—Ç {winnings} —Ñ–∏—à–µ–∫."
                    ), 0, {}
                return winnings, (
                    f"{self._wild} –¥–æ–ø–æ–ª–Ω–∏–ª –≤–∞—à –≤—ã–∏–≥—Ä—ã—à! –ü–∞—Ä–∞ {best_symbol} –ø—Ä–∏–Ω–æ—Å–∏—Ç {winnings} —Ñ–∏—à–µ–∫."
                ), 0, {}

        if len(set(symbols)) == 1 and symbols[0] != self._wild:
            symbol = symbols[0]
            multiplier = self._triple_payouts.get(symbol, 0)
            if multiplier:
                winnings = bet * multiplier
                return winnings, "–¢—Ä–∏ {0}! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ {1} —Ñ–∏—à–µ–∫.".format(symbol, winnings), 0, {}

        counts = {s: symbols.count(s) for s in set(symbols) if s != self._wild}
        for symbol, count in counts.items():
            if count == 2:
                multiplier = self._double_payouts.get(symbol, 0)
                if multiplier:
                    winnings = bet * multiplier
                    return winnings, "–ü–∞—Ä–∞ {0} –ø—Ä–∏–Ω–æ—Å–∏—Ç {1} —Ñ–∏—à–µ–∫.".format(symbol, winnings), 0, {}

        return 0, "–ü–µ—Å–∫–∏ –ø—É—Å—Ç—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑!", 0, {}

    def _choose_best_symbol(self, symbols: list[str]) -> str:
        best = symbols[0]
        best_score = self._score_symbol(best)
        for symbol in symbols[1:]:
            score = self._score_symbol(symbol)
            if score > best_score:
                best = symbol
                best_score = score
        return best

    def _score_symbol(self, symbol: str) -> int:
        return self._triple_payouts.get(symbol, 0) * 10 + self._double_payouts.get(symbol, 0)

    def supports_jackpot(self) -> bool:
        return True

    def jackpot_contribution(self, bet: int) -> int:
        contribution = int(bet * self._jackpot_percent)
        if contribution <= 0 and bet > 0:
            contribution = 5
        return contribution


class PirateMachine(SlotMachine):
    key = "pirate"
    title = "–°–æ–∫—Ä–æ–≤–∏—â–∞ –ü–∏—Ä–∞—Ç–∞"
    description = "–°–æ–±–µ—Ä–∏ 3 –∫–∞—Ä—Ç—ã üó∫Ô∏è –∏ –ø–æ–ª—É—á–∏ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≤—Ä–∞—â–µ–Ω–∏—è!"

    _scatter = "üó∫Ô∏è"

    def __init__(self) -> None:
        super().__init__(("üè¥‚Äç‚ò†Ô∏è", "ü¶ú", "üí£", "üíé", "‚öì", self._scatter))

    def evaluate(
        self, symbols: tuple[str, str, str], bet: int, jackpot_balance: int
    ) -> tuple[int, str, int, dict[str, int]]:
        scatter_count = symbols.count(self._scatter)
        if scatter_count == 3:
            return (0, "–í—ã –Ω–∞—à–ª–∏ –∫–∞—Ä—Ç—É —Å–æ–∫—Ä–æ–≤–∏—â! –ó–∞–ø—É—Å–∫–∞—é—Ç—Å—è 10 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≤—Ä–∞—â–µ–Ω–∏–π!", 0, {"free_spins": 10})

        if symbols[0] == symbols[1] == symbols[2]:
            multiplier = {"üè¥‚Äç‚ò†Ô∏è": 30, "ü¶ú": 20, "üí£": 15, "üíé": 10, "‚öì": 6}.get(symbols[0], 8)
            winnings = bet * multiplier
            return winnings, f"–¢—Ä–∏ {symbols[0]}! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ {winnings} —Ñ–∏—à–µ–∫.", 0, {}

        unique = len(set(symbols))
        if unique == 2:
            counts = {symbol: symbols.count(symbol) for symbol in set(symbols) if symbol != self._scatter}
            for symbol, count in counts.items():
                if count == 2:
                    winnings = bet * 2
                    return winnings, f"–ü–∞—Ä–∞ {symbol}! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ {winnings} —Ñ–∏—à–µ–∫.", 0, {}

        return 0, "–®—Ç–æ—Ä–º–∞ –±—É—à—É—é—Ç ‚Äì –ø–æ–∫–∞ –±–µ–∑ –≤—ã–∏–≥—Ä—ã—à–∞!", 0, {}

    def supports_jackpot(self) -> bool:
        return False
